#include <bits/stdc++.h>
using namespace std;

int n;
int a[2005];
int d[2005][2005]; // d[i][j]: i번째 수부터 j번째 수까지의 팰린드롬의 여부를 저장하는 배열. 
// 팰린드롬이면 1, 팰린드롬이 아니면 0.

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];

	for (int i = 1; i <= n; i++) {
		d[i][i] = 1;

    //이때 의미적으로 사용하지 않는 a[0]에 접근하는데, 어차피 a[1]부터 문제의 조건상 자연수기 때문에
		//절대로 a[0]과 a[1]이 같을수가 없다. 그래서 a[0]에서 예외처리가 되도록 따로
		//코드를 작성하지 않아도 된다. 
		if (a[i - 1] == a[i]) d[i - 1][i] = 1;
	}


  /*
	위에서 갭이 1일대, 갭이 0일때를 따로 구분지어서 dp배열에 설정하는 이유는
	아래 갭이 2이상일때의 상황에서 DP배열을 활용해서 다음 DP배열을 채우는데 사용하는 관계식이
	다르기 때문이다. 이런식의 계산을 해놓아야 지속적으로 갭이 2이상인 경우에 대해서 
	작성할 수 있고, 저러한 관계식은 갭이 0, 갭이 1인 경우 사용할수가 없다. 
	그렇기 때문에 이런식으로 구분을 지어서 작성을 해야한다. 
	
	*/
	for (int gap = 2; gap < n; gap++) {//gap을 시작점 i에 더할 것이기 때문에 gap은 n보다 작아야 한다
		for (int i = 1; i <= n - gap; i++) {
			int s = i;
			int e = i + gap;
			
			// a[s]과 a[e]항이 같고, 그 사이에 나온 수열이 팰린드롬 이라면
			//(여기서 && d[s+1][e-1]이라고 써놓은건, && d[s+1][e-1]==1 이라고 써놓은것과 같다
			// 's+1 ~ e-1 항까지의 수열이 팰린드롬이라면' 을 의미한다.
			if (a[s] == a[e] && d[s + 1][e - 1]) d[s][e] = 1;
		}
	}

  int t;
  cin>>t;
  while(t--){
    int s, e;
    cin>>s>>e;
    cout<<d[s][e]<<'\n';
  }
}