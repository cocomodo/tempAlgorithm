#include <bits/stdc++.h>
using namespace std;

int n;
int a[5005];
int d[5005];
int mod = 1'000'000;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	string s;
	cin >> s;
	n = s.size();
	for (int i = 1; i <= n; i++)
		a[i] = s[i - 1] - '0';
	d[0] = 1; // 이렇게 경우의 수의 문제의 경우, 아무것도 없는 경우 같은 경우는 한가지가 된다
	for (int i = 1; i <= n; i++) {
		if (a[i] > 0) // 이 얘기는, a[i]= 1,2,3,4,5,6,7,8,9 의 경우로 가능하다는 얘기
		/*
		원래 d[i]+=d[i-1]; 꼴의 형태로 작성하는 부분이지만
		모듈러 연산을 해주어야 하기 때문에
		d[i]= d[i]+d[i-1]; 형태로 작성하는 코드에
		d[i]=(d[i]+d[i-1])%mod; 를 해준것으로 보인다. 
		이건 결국 d[i]의 가능한 가지수에, d[i-1]을 추가적으로
		더한다는 의미로 d[i]+=d[i-1]을 사용하는것이라고 이해하는게
		정확할것 같다. 
		*/
		/*
		d[i]=d[i-1]%mod; 로 작성하여도 동일한 동작을 하는데, 
		d[i-1]의 경우의 수에 한글자를 추가적으로 사용하여서 동일한 가지수를
		d[i]에 추가한다는 의미로 
		d[i]=(d[i]+d[i-1])%mod;로 작성하게 더 좋을것으로 보여진다. 
		*/
			d[i] = (d[i] + d[i - 1]) % mod; // 그 전항의 최대 경우의 수에 한 글자만 더 하면 전체 그 경우의 수와 같다. 
		int x = a[i - 1] * 10 + a[i];//현재의 수와 그 전 수가 10~26사이의 값을 가진다면, 새로운 단어로 해석할 수 있으므로
		if (x >= 10 && x <= 26)
			d[i] = (d[i] + d[i - 2]) % mod; // d[i-2]에 새로운 단어로 해석할 수 있는 경우의 그 단어를 붙이면 되므로
	}
	cout << d[n];
}